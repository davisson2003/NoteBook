Dex2oat
Workflow:
* Dex2oat initialize.
* dex2oat.ParseArgs(argc, argv): 
  ** initialize locking, logging, gCommandLine.
  ** parse options from command.
  ** process options.
* dex2oat.OpenFile(), try to open the oat file for saving result.
* dex2oat.Setup()
* CompileImage() or CompileApp()
* dex2oat.ShutDown()


=================== DataStructure =============================================

-------------------- VerificationResults -------------------------------------
<src art/compiler/dex/verification_results.cc>


class VerificationResults {
  const CompilerOptions* const compiler_options_;
  typedef SafeMap<MethodReference, VerifiedMethod*, MethodReferenceComparator> VerifiedMethodMap;
  
  ReaderWriterMutex verified_methods_lock_;
  VerifiedMethodMap verified_methods_;

  ReaderWriterMutex  rejected_classes_lock_;
  std::set<ClassReference> rejected_classes_;
}
--------------------
Description:
The important DS in VerificationResults are :
* a Map between MethodReference and VerifiedMethod. holding the verified method.
* a set of ClassReference. holding the rejected classes.

===================== MethodReference / DexFileReference =============================
struct MethodReference {
  const DexFile* dex_file_;
  uint32_t dex_method_index;
}

struct DexFileReference {
  const DexFile* dex_file_;
  uint32_t index;
}

// A class is uniquely located by its DexFile and the class_defs_ table index in that dex file
typedef std::pair<const DexFile*, uint32_t> ClassReference;

-----------------
Desc:
MethodReference holds info where we can find the Method from dex file:
dexfile ptr and method index.


==================== VerifiedMethod =================================================
class VerifiedMethod {
  public:
    // typedefs
    typedef std::vector<uint32_t> SafeCastSet;
    // DevirtualizationMap, maps dex offset to MethodReference.
    typedef SafeMap<uint32_t, MethodReference> DevirtualizationMap;
    // DequickenMap, maps dex offset to DexFileReference (field/method idx). 
    typedef SafeMap<uint32_t, DexFileReference> DequickenMap; 

  private:
    std::vector<uint8_t> dex_gc_map_; // virtual register reference map.
    DervitualizationMap devirt_map_; 
    // Dequicken map is required for compiling quickened byte codes.
    // The quicken maps from dex PC to dex method/field index based on instruction.
    DequickenMap dequicken_map_;
    
    SafeCastSet safe_cast_set_;
    const uint32_t encountered_error_types_; 
    const bool has_runtime_throw_;

    // Copy of mapping generated by verifier of dex PCs of string init invocations
    // to the set of other registers that the receiver has been copied into. 
    const SafeMap<uint32_t, std::set<uint32_t>> string_init_pc_reg_map_;
}

-----------------
Desc:
VerifiedMethod holds all info about method after verification.
* dex_gc_map_:
    first 4 bytes:
    ** 1st byte : ref_bitmap_bytes (high 5 bits) : format (3bits)
    ** 2nd byte : ref_bitmap_bytes (low 8 bits)
    ** 3ed byte : number enteries (low 8 bits)
    ** 4th byte : number enteries (hign 8 bits)
    ** ((pc_bytes + ref_bitmap_bytes) * num_entries) 
    ** per entry: pc_bytes (1 or 2, determined by format) : bitmaps (1 for reference vr.) 

------------------
======================================================================================================
======================================================================================================
======================================================================================================

====================== QuickCompilerCallbacks =======================================================
<src art/compiler/dex/quick_compiler_callbacks.h>
<Derived from CompilerCallbacks>

class QuickCompilerCallbacks FINAL : public CompilerCallbacks {
 private:
   
   VerificationResults* const verification_results_;
   DexFileToMethodInlinerMap* const method_inliner_map_;
}

class CompilerCallbacks {
   enum class CallbackMode { 
      kCompileBootImage,
      kCompileApp
   }
 // Whether the compiler is creating a boot image.   
   const CallbackMode mode_;  
}

--------------------- DexFileToMethodInlinerMap -----------------------------------
<src art/compiler/dex/quick/dex_file_to_method_inliner_map.h>

/**
 * Map each DexFile to its DexFileMethodInliner.
 *
 * The method inliner is created and initialized the first time it's requested
 * for a particular DexFile.
 */
class DexFileToMethodInlinerMap {
 private:

    ReaderWriterMutex lock_;
    std::map<const DexFile*, DexFileMethodInliner*> inliners_
}

--------------------- DexFileMethodInliner ----------------------------------------
<src art/compiler/dex/quick/dex_file_method_inliner.h>

/**
 * Handles inlining of methods from a particular DexFile.
 *
 * Intrinsics are a special case of inline methods. The DexFile indices for
 * all the supported intrinsic methods are looked up once by the FindIntrinsics
 * function and cached by this class for quick lookup by the method index.
 *
 * TODO: Detect short methods (at least getters, setters and empty functions)
 * from the verifier and mark them for inlining. Inline these methods early
 * during compilation to allow further optimizations. Similarly, provide
 * additional information about intrinsics to the early phases of compilation.
 */
class DexFileMethodInliner {

    /**
     * To avoid multiple lookups of a class by its descriptor, we cache its
     * type index in the IndexCache. These are the indexes into the IndexCache
     * class_indexes array.
     */
    enum ClassCacheIndex : uint8_t {  // unit8_t to save space, make larger if needed
      kClassCacheFirst = 0,
      kClassCacheBoolean = kClassCacheFirst,
      kClassCacheByte,
      kClassCacheChar,
      kClassCacheShort,
      kClassCacheInt,
      kClassCacheLong,
      kClassCacheFloat,
      kClassCacheDouble,
      kClassCacheVoid,
      kClassCacheJavaLangByteArray,
      kClassCacheJavaLangCharArray,
      kClassCacheJavaLangIntArray,
      kClassCacheJavaLangObject,
      kClassCacheJavaLangRefReference,
      kClassCacheJavaLangString,
      kClassCacheJavaLangStringBuffer,
      kClassCacheJavaLangStringBuilder,
      kClassCacheJavaLangStringFactory,
      kClassCacheJavaLangDouble,
      kClassCacheJavaLangFloat,
      kClassCacheJavaLangInteger,
      kClassCacheJavaLangLong,
      kClassCacheJavaLangShort,
      kClassCacheJavaLangMath,
      kClassCacheJavaLangStrictMath,
      kClassCacheJavaLangThread,
      kClassCacheJavaNioCharsetCharset,
      kClassCacheLibcoreIoMemory,
      kClassCacheSunMiscUnsafe,
      kClassCacheJavaLangSystem,
      kClassCacheLast
    };

    /**
     * To avoid multiple lookups of a method name string, we cache its string
     * index in the IndexCache. These are the indexes into the IndexCache
     * name_indexes array.
     */
    enum NameCacheIndex : uint8_t {  // unit8_t to save space, make larger if needed
      kNameCacheFirst = 0,
      kNameCacheReverse =  kNameCacheFirst,
      kNameCacheReverseBytes,
      kNameCacheDoubleToRawLongBits,
      kNameCacheLongBitsToDouble,
      kNameCacheFloatToRawIntBits,
      kNameCacheIntBitsToFloat,
      kNameCacheAbs,
      kNameCacheMax,
      kNameCacheMin,
      kNameCacheSqrt,
      kNameCacheCeil,
      kNameCacheFloor,
      kNameCacheRint,
      kNameCacheRound,
      kNameCacheReferenceGetReferent,
      kNameCacheCharAt,
      kNameCacheCompareTo,
      kNameCacheEquals,
      kNameCacheGetCharsNoCheck,
      kNameCacheIsEmpty,
      kNameCacheIndexOf,
      kNameCacheLength,
      kNameCacheInit,
      kNameCacheNewStringFromBytes,
      kNameCacheNewStringFromChars,
      kNameCacheNewStringFromString,
      kNameCacheCurrentThread,
      kNameCachePeekByte,
      kNameCachePeekIntNative,
      kNameCachePeekLongNative,
      kNameCachePeekShortNative,
      kNameCachePokeByte,
      kNameCachePokeIntNative,
      kNameCachePokeLongNative,
      kNameCachePokeShortNative,
      kNameCacheCompareAndSwapInt,
      kNameCacheCompareAndSwapLong,
      kNameCacheCompareAndSwapObject,
      kNameCacheGetInt,
      kNameCacheGetIntVolatile,
      kNameCachePutInt,
      kNameCachePutIntVolatile,
      kNameCachePutOrderedInt,
      kNameCacheGetLong,
      kNameCacheGetLongVolatile,
      kNameCachePutLong,
      kNameCachePutLongVolatile,
      kNameCachePutOrderedLong,
      kNameCacheGetObject,
      kNameCacheGetObjectVolatile,
      kNameCachePutObject,
      kNameCachePutObjectVolatile,
      kNameCachePutOrderedObject,
      kNameCacheArrayCopy,
      kNameCacheNumberOfLeadingZeros,
      kNameCacheNumberOfTrailingZeros,
      kNameCacheRotateRight,
      kNameCacheRotateLeft,
      kNameCacheLast
    };

    /**
     * To avoid multiple lookups of a method signature, we cache its proto
     * index in the IndexCache. These are the indexes into the IndexCache
     * proto_indexes array.
     */
    enum ProtoCacheIndex : uint8_t {  // unit8_t to save space, make larger if needed
      kProtoCacheFirst = 0,
      kProtoCacheI_I = kProtoCacheFirst,
      kProtoCacheJ_J,
      kProtoCacheS_S,
      kProtoCacheD_D,
      kProtoCacheDD_D,
      kProtoCacheF_F,
      kProtoCacheFF_F,
      kProtoCacheD_J,
      kProtoCacheJ_D,
      kProtoCacheF_I,
      kProtoCacheI_F,
      kProtoCacheII_I,
      kProtoCacheI_C,
      kProtoCacheString_I,
      kProtoCache_Z,
      kProtoCache_I,
      kProtoCache_Object,
      kProtoCache_Thread,
      kProtoCacheJ_B,
      kProtoCacheJ_I,
      kProtoCacheJ_S,
      kProtoCacheJB_V,
      kProtoCacheJI_V,
      kProtoCacheJJ_J,
      kProtoCacheJJ_V,
      kProtoCacheJS_V,
      kProtoCacheObject_Z,
      kProtoCacheJI_J,
      kProtoCacheObjectJII_Z,
      kProtoCacheObjectJJJ_Z,
      kProtoCacheObjectJObjectObject_Z,
      kProtoCacheObjectJ_I,
      kProtoCacheObjectJI_V,
      kProtoCacheObjectJ_J,
      kProtoCacheObjectJJ_V,
      kProtoCacheObjectJ_Object,
      kProtoCacheObjectJObject_V,
      kProtoCacheCharArrayICharArrayII_V,
      kProtoCacheObjectIObjectII_V,
      kProtoCacheIICharArrayI_V,
      kProtoCacheByteArrayIII_String,
      kProtoCacheIICharArray_String,
      kProtoCacheString_String,
      kProtoCache_V,
      kProtoCacheByteArray_V,
      kProtoCacheByteArrayI_V,
      kProtoCacheByteArrayII_V,
      kProtoCacheByteArrayIII_V,
      kProtoCacheByteArrayIIString_V,
      kProtoCacheByteArrayString_V,
      kProtoCacheByteArrayIICharset_V,
      kProtoCacheByteArrayCharset_V,
      kProtoCacheCharArray_V,
      kProtoCacheCharArrayII_V,
      kProtoCacheIICharArray_V,
      kProtoCacheIntArrayII_V,
      kProtoCacheString_V,
      kProtoCacheStringBuffer_V,
      kProtoCacheStringBuilder_V,
      kProtoCacheLast
    };

  private:
    /**
     * The maximum number of method parameters we support in the ProtoDef.
     */
    static constexpr uint32_t kProtoMaxParams = 6;

    /**
     * The method signature (proto) definition using cached class indexes.
     * The return_type and params are used with the IndexCache to look up
     * appropriate class indexes to be passed to DexFile::FindProtoId().
     */
    struct ProtoDef {
      ClassCacheIndex return_type;
      uint8_t param_count;
      ClassCacheIndex params[kProtoMaxParams];
    };

    /**
     * The method definition using cached class, name and proto indexes.
     * The class index, method name index and proto index are used with
     * IndexCache to look up appropriate parameters for DexFile::FindMethodId().
     */
    struct MethodDef {
      ClassCacheIndex declaring_class;
      NameCacheIndex name;
      ProtoCacheIndex proto;
    };

    /**
     * The definition of an intrinsic function binds the method definition
     * to an Intrinsic.
     */
    struct IntrinsicDef {
      MethodDef method_def;
      InlineMethod intrinsic;
    };

    /**
     * Cache for class, method name and method signature indexes used during
     * intrinsic function lookup to avoid multiple lookups of the same items.
     *
     * Many classes have multiple intrinsics and/or they are used in multiple
     * method signatures and we want to avoid repeated lookups since they are
     * not exactly cheap. The method names and method signatures are sometimes
     * reused and therefore cached as well.
     */
    struct IndexCache {
      IndexCache();

      uint32_t class_indexes[kClassCacheLast - kClassCacheFirst];
      uint32_t name_indexes[kNameCacheLast - kNameCacheFirst];
      uint32_t proto_indexes[kProtoCacheLast - kProtoCacheFirst];
    };

    static const char* const kClassCacheNames[];
    static const char* const kNameCacheNames[];
    static const ProtoDef kProtoCacheDefs[];
    static const IntrinsicDef kIntrinsicMethods[];

    static const uint32_t kIndexNotFound = static_cast<uint32_t>(-1);
    static const uint32_t kIndexUnresolved = static_cast<uint32_t>(-2);

    ReaderWriterMutex lock_;
    /*
     * Maps method indexes (for the particular DexFile) to Intrinsic defintions.
     */
    SafeMap<uint32_t, InlineMethod> inline_methods_ GUARDED_BY(lock_);
    const DexFile* dex_file_;
};
---------------- InlineMethod ---------------------------------------------------
<src art/runtime/quick/inline_method_analyser.h>
struce InlineMethod {
  InlineMethodOpcode opcode;
  InlineMethodFlags flag;
  union {
    uint64_t data;
    InlineIGetIPutData ifield_data;
    InlineReturnArgData return_data;
  } d;
}
-------
Desc:
* InlineMethodOpcode contains intrinsics (like kIntrinsicIndexOf) and InlineOp (kInlineOpNop, ReturnArg, NonWideConst,IGet/IPut and StringInit)
* InlineMethodFlags : NoInlineMethodFlags, kInlineIntrinsic ,  kInlineSpecial 
* InlineIGetIPutData: 
    struct InlineIGetIPutData {
      // The op_variant below is DexMemAccessType but the runtime doesn't know that enumeration.
      uint16_t op_variant : 3;
      uint16_t method_is_static : 1;
      uint16_t object_arg : 4;
      uint16_t src_arg : 4;  // iput only
      uint16_t return_arg_plus1 : 4;  // iput only, method argument to return + 1, 0 = return void.
      uint16_t field_idx;
      uint32_t is_volatile : 1;
      uint32_t field_offset : 31;
    };
* InlineReturuArgData: 
    struct InlineReturnArgData {
      uint16_t arg;
      uint16_t is_wide : 1;
      uint16_t uint16_t is_object : 1;
      uint16_t reserved : 14;
      uint32_t reserved2;
    };
------------------------------------------------------------------------------------------
******************************************************************************************
******************************************************************************************
QuickCompilerCallbacks() Desc:
* it contains two components:
  ** verification_results_ contains:
    *** compiler_options_,
    *** VerifiedMethodMap verified_methods_; contains MethodReference(dexfile+index) and VerifiedMethods(meta info like gc map.) 
    *** rejected classes set.
  ** method_inliner_map, contains:
    *** inliners_ (map with dexfile and DexFileMethodInliner(contains dexfile and map<m_index, InlineMethod>))
    InlineMethod describes the method need to be inlined (opcode, flag, data).
    
===========================================================================================
===========================================================================================


===========================================================================================
=================== PrepareRuntimeOptions() ===============================================
<src dex2oat/dex2oat.cc>
* Runtime-option  --- value --- (dex2oat options)

* "-Xbootclasspath:" --- dex_filenames_ (--dex-file=)
* "-Xbootclasspath-locations:" --- dex_locations_ ("--dex-location=")
* "-Ximage:" --- boot_image_fileiname_ (--boot-image= or getenv(ANDROID_ROOT) + "/framework/boot.art")
* "compilercallbacks" --- callback
* "imageinstructionset" --- GetInstructionSetString(instruction_set)
* "-Xno-dex-file-fallback" --- nullptr (only if !BootImage())
* "-Xno-sig-chain" --- nullptr

==========================================================================================
=================== CreateRuntime(std::move(runtime_options)) ============================
<src dex2oat/dex2oat.cc>

1. Runtime::Create(std::move(runtime_options)) to create runtime with the option

2. runtime_->SetInstructionSet(instruction_set_) 
  * this set the instruction_set_ and 
  * initialize Runtime::callee_save_method_frame_infos_[i] to XXXCalleeSaveMethodFrameInfo(type), which actually create QuickMethodFrameInfo.
  Here i and type is the iteration of CalleeSaveType (kSaveAll, kRefsOnly, kRefsAndArgs)
  * init of XXXCalleeSaveMethodFrameInfo(type) inside create QuickMethodFrameInfo, and initialize the frame_size_in_bytes_, core_spill_mask_ and fp_spill_mask_ field due to the type parameter.
  ** Different ARCHs: (****** CALLING CONVENTION **********)
 
  ** ARM:
     1. Register Code: 
        R0 -- R15 ( from 0 to 15), TR = 9(thread register), FP = 11, IP = 12, SP = 13, LR = 14, PC=15
  
     2. CalleeSave Regs:
        kArmCalleeSaveAlwaysSpills: LR
        kArmCalleeSaveRefSpills: R5, R6, R7, R8, R10, R11.
        Args Regs: kArmCalleeSaveArgSpills: R1, R2, R3
        kArmCalleeSaveAllSpills: R4, R9
        
        kArmCalleeSaveFpArgSpills: S0--S15
        kArmCalleeSaveFpAllSpills: S16--S32
        others for FP are 0(means null)

     3. QuickMethodFrameInfo( frame_size_in_bytes, core_spills, fp_spills) 
        * frame_size_in_bytes is calculated by:
          (
           POPCOUNT(ArmCalleeSaveCoreSpills(type)) /* gprs */ +
           POPCOUNT(ArmCalleeSaveFpSpills(type)) /* fprs */ +
           1 /* Method* */
          ) * kArmPointerSize

        * CoreSpills: 
          kArmCalleeSaveAlwaysSpills | 
          kArmCalleeSaveRefSpills |
          (type == Runtime::kRefsAndArgs ? kArmCalleeSaveArgSpills : 0) |
          (type == Runtime::kSaveAll ? kArmCalleeSaveAllSpills : 0)
     
        * FpSpills:
          kArmCalleeSaveFpAlwaysSpills | 
          kArmCalleeSaveFpRefSpills | 
          (type == Runtime::kRefsAndArgs ? kArmCalleeSaveFpArgSpills: 0) | 
          (type == Runtime::kSaveAll ? kArmCalleeSaveFpAllSpills : 0)

  ** X86:
     1. Register Code: EAX, ECX, EDX, EBX, ESP, EBP, ESI, EDI (from 0 to 7)
        KNumberOfCpuRegisters = 8;
        kFirstByteUnsafeRegister = 4;
        kNoRegister = -1;

     2. CalleeSave Regs: kX86CalleeSaveRefSpills = EBP, ESI, EDI for "1" at bit mask.  
        Args Regs: kX86CalleeSaveArgSpills = ECX, EDX, EBX for "1" at bit mask.
        XMM: kX86CalleeSaveFpArgSpills = XMM0--XMM3

     3. QuickMethodFrameInfo( frame_size_in_bytes, core_spills, fp_spills) 
        * frame_size_in_bytes is calculated by:
           (
            POPCOUNT(X86CalleeSaveCoreSpills(type)) /* gprs */ + 
            2 * POPCOUNT(X86CalleeSaveFpSpills(type)) /* fprs */ + 
            1 /* Method* */
           ) * kX86PointerSize 

        * CoreSpills: 
        ** type == kSaveAll or kRefsOnly, it is kX86CalleeSaveRefSpills | 1 << art::x86::kNumberOfCpuRegisters) // for return address callee save.
        ** type == kRefsAndArgs, it is kX86CalleeSaveRefSpills | kX86CalleeSaveArgsSpills | 1 << kNumberOfCpuRegisters

        * FpSpills:
        kX86CalleeSaveFpArgsSpill for type == kRefsAndArgs, 0 otherwise.


  ** X86_64:
     1. Register Code: RAX, RCX, RDX, RBX, RSP, RBP, RSI, RDI, R8, R9, R10, R11, R12, R13, R14, R15 (from 0 to 15)
        kLastCpuRegister = 15,
        KNumberOfCpuRegisters = 16;
        kNoRegister = -1;

     2. CalleeSave Regs: kX86_64CalleeSaveRefSpills = RBX, RBP, R12, R13, R14, R15 for "1" at bit mask.  
        Args Regs: kX86_64CalleeSaveArgSpills = RSI, RDX, RCX, R8, R9 for "1" at bit mask.
        XMM: 
            kX86_64CalleeSaveFpSpills = XMM12 -- XMM15
            kX86_64CalleeSaveFpArgSpills = XMM0 -- XMM7

     3. QuickMethodFrameInfo( frame_size_in_bytes, core_spills, fp_spills) 
        * frame_size_in_bytes is calculated by:
           (
            POPCOUNT(X86_64CalleeSaveCoreSpills(type)) /* gprs */ + 
            POPCOUNT(X86_64CalleeSaveFpSpills(type)) /* fprs */ + 
            1 /* Method* */
           ) * kX86PointerSize 

        * CoreSpills: 
        ** type == kSaveAll or kRefsOnly, it is kX86_64CalleeSaveRefSpills | 1 << art::x86_64::kNumberOfCpuRegisters) // for return address callee save.
        ** type == kRefsAndArgs, it is kX86_64CalleeSaveRefSpills | kX86_64CalleeSaveArgsSpills | 1 << kNumberOfCpuRegisters

        * FpSpills:
        X86_64CalleeSaveFpSpills| X86_64CalleeSaveFpArgsSpill for type == kRefsAndArgs, 
        X86_64CalleeSaveFpSpills otherwise.


3. if calleeSaveMethod for calleeSaveType i not exist. create one:
   runtime_->SetCalleeSaveMethod(runtime_->CreateCalleeSaveMethod(), type);
   
   * Runtime::SetCalleeSaveMethod(Artmethod* method, CalleeSaveType type) just set the  callee_save_methods_[type] = method.
   * Runtime::CreateCalleeSaveMethod(): 
     ** auto* method = Runtime::Current()->GetClassLinker()->CreateRuntimeMethod();
       *** Allocate a 1 length MethodArray in LinearAlloc(),  ArtMethod* method = &method_array->At(0, method_size, method_alignment); 
       *** and method have no dexMethodIndex.  method->SetDexMethodIndex(DexFile::kDexNoIndex); 
       *** method content is not initialized, supposed to be all 0s.

     ** method->SetEntryPointFromQuickCompiledCodePtrSize(nullptr, pointer_size); 
       *** ((ArtMethod*)method)->ptr_sized_fields_-> entry_point_from_quick_compiled_code_ = nullptr
 -------------------------------------------------------------------------------------------------------------
 ----------- class ArtMethod --------------------------------------------------------------------------------
 
 class ArtMethod {

   protected: 

    // class we are part of.
    GcRoot<mirror::Class> declaring_class_;   
    
    // Access flags; low 16 bits are defined by spec.
    uint32_t access_flags_; 

    /* Dex file fields. The defining dex file is available via declaring_class_->dex_cache_ */

    // offset of the dex code item.
    uint32_t dex_code_item_offset;

    // index of the method_ids of the dex file for this method
    uint32_t dex_method_index;

     /* End of dex file fields. */   

    // Entry within a dispatch table for this method.
    // for static/direct methods the index is into the declaring_class_.directMethods.
    // for virtual methods the index is into the vtable.
    // for interface methods the index is into the iftable.
    uint16_t method_index;

    // The hotness we measure for the method. incremented by interpreter, Not atomic as it is ok to missing some inc.
    uint16_t hotness.
    
    // Fake padding fields get inserted here.

    // Must be the last fields in the method.
    // PACKED(4) is necessory for correctness of
    // RoundUp(OFFSETOF_MEMBER(ArtMethod, ptr_sized_fields_), pointer_size). 
    struct PACKED(4) PtrSizedFields {
     
      // Short cuts to declaring_class_->dex_cache_ member for fast compiled code access
      ArtMethod** dex_cache_resolved_methods_;

      // Short cuts to declaring_class_->dex_cache_ member for fast compiled code access
      GcRoot(mirror::Class>* dex_cache_resolved_types_;

      // Ptr to JNI function registered to this method. or a function to resolve the JNI function.
      // or the profiling data for non-native methods.
      void* entry_point_from_jni_;

      // Method dispatch from quick compiled code invokes this ptr which may cause bridging into the interpreter.
      void* entry_point_from_compiled_code;

    } ptr_sized_fields_;
 };

------------- Desc: ------------------
ArtMethod contains info the runtime execution/ compiler/JIT compiler needs.
if method->dex_method_idx ==  DexFile::kDexNoIndex; means it is runtime method. not created from java.

--------------------------------------------------------------------------------------------------------------

4. FixupDexCaches with runtime_->GetResolutionMethod();
 
