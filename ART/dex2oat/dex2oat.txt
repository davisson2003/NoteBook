Dex2oat
Workflow:
* Dex2oat initialize.
* dex2oat.ParseArgs(argc, argv): 
  ** initialize locking, logging, gCommandLine.
  ** parse options from command.
  ** process options.
* dex2oat.OpenFile(), try to open the oat file for saving result.
* dex2oat.Setup()
* CompileImage() or CompileApp()
* dex2oat.ShutDown()


=================== DataStructure =============================================

-------------------- VerificationResults -------------------------------------
<src art/compiler/dex/verification_results.cc>


class VerificationResults {
  const CompilerOptions* const compiler_options_;
  typedef SafeMap<MethodReference, VerifiedMethod*, MethodReferenceComparator> VerifiedMethodMap;
  
  ReaderWriterMutex verified_methods_lock_;
  VerifiedMethodMap verified_methods_;

  ReaderWriterMutex  rejected_classes_lock_;
  std::set<ClassReference> rejected_classes_;
}
--------------------
Description:
The important DS in VerificationResults are :
* a Map between MethodReference and VerifiedMethod. holding the verified method.
* a set of ClassReference. holding the rejected classes.

===================== MethodReference / DexFileReference =============================
struct MethodReference {
  const DexFile* dex_file_;
  uint32_t dex_method_index;
}

struct DexFileReference {
  const DexFile* dex_file_;
  uint32_t index;
}

// A class is uniquely located by its DexFile and the class_defs_ table index in that dex file
typedef std::pair<const DexFile*, uint32_t> ClassReference;

-----------------
Desc:
MethodReference holds info where we can find the Method from dex file:
dexfile ptr and method index.


==================== VerifiedMethod =================================================
class VerifiedMethod {
  public:
    // typedefs
    typedef std::vector<uint32_t> SafeCastSet;
    // DevirtualizationMap, maps dex offset to MethodReference.
    typedef SafeMap<uint32_t, MethodReference> DevirtualizationMap;
    // DequickenMap, maps dex offset to DexFileReference (field/method idx). 
    typedef SafeMap<uint32_t, DexFileReference> DequickenMap; 

  private:
    std::vector<uint8_t> dex_gc_map_; // virtual register reference map.
    DervitualizationMap devirt_map_; 
    // Dequicken map is required for compiling quickened byte codes.
    // The quicken maps from dex PC to dex method/field index based on instruction.
    DequickenMap dequicken_map_;
    
    SafeCastSet safe_cast_set_;
    const uint32_t encountered_error_types_; 
    const bool has_runtime_throw_;

    // Copy of mapping generated by verifier of dex PCs of string init invocations
    // to the set of other registers that the receiver has been copied into. 
    const SafeMap<uint32_t, std::set<uint32_t>> string_init_pc_reg_map_;
}

-----------------
Desc:
VerifiedMethod holds all info about method after verification.
* dex_gc_map_:
    first 4 bytes:
    ** 1st byte : ref_bitmap_bytes (high 5 bits) : format (3bits)
    ** 2nd byte : ref_bitmap_bytes (low 8 bits)
    ** 3ed byte : number enteries (low 8 bits)
    ** 4th byte : number enteries (hign 8 bits)
    ** ((pc_bytes + ref_bitmap_bytes) * num_entries) 
    ** per entry: pc_bytes (1 or 2, determined by format) : bitmaps (1 for reference vr.) 

------------------
======================================================================================================
======================================================================================================
======================================================================================================

====================== QuickCompilerCallbacks =======================================================
<src art/compiler/dex/quick_compiler_callbacks.h>
<Derived from CompilerCallbacks>

class QuickCompilerCallbacks FINAL : public CompilerCallbacks {
 private:
   
   VerificationResults* const verification_results_;
   DexFileToMethodInlinerMap* const method_inliner_map_;
}

class CompilerCallbacks {
   enum class CallbackMode { 
      kCompileBootImage,
      kCompileApp
   }
 // Whether the compiler is creating a boot image.   
   const CallbackMode mode_;  
}

--------------------- DexFileToMethodInlinerMap -----------------------------------
<src art/compiler/dex/quick/dex_file_to_method_inliner_map.h>

/**
 * Map each DexFile to its DexFileMethodInliner.
 *
 * The method inliner is created and initialized the first time it's requested
 * for a particular DexFile.
 */
class DexFileToMethodInlinerMap {
 private:

    ReaderWriterMutex lock_;
    std::map<const DexFile*, DexFileMethodInliner*> inliners_
}

--------------------- DexFileMethodInliner ----------------------------------------
<src art/compiler/dex/quick/dex_file_method_inliner.h>

/**
 * Handles inlining of methods from a particular DexFile.
 *
 * Intrinsics are a special case of inline methods. The DexFile indices for
 * all the supported intrinsic methods are looked up once by the FindIntrinsics
 * function and cached by this class for quick lookup by the method index.
 *
 * TODO: Detect short methods (at least getters, setters and empty functions)
 * from the verifier and mark them for inlining. Inline these methods early
 * during compilation to allow further optimizations. Similarly, provide
 * additional information about intrinsics to the early phases of compilation.
 */
class DexFileMethodInliner {

    /**
     * To avoid multiple lookups of a class by its descriptor, we cache its
     * type index in the IndexCache. These are the indexes into the IndexCache
     * class_indexes array.
     */
    enum ClassCacheIndex : uint8_t {  // unit8_t to save space, make larger if needed
      kClassCacheFirst = 0,
      kClassCacheBoolean = kClassCacheFirst,
      kClassCacheByte,
      kClassCacheChar,
      kClassCacheShort,
      kClassCacheInt,
      kClassCacheLong,
      kClassCacheFloat,
      kClassCacheDouble,
      kClassCacheVoid,
      kClassCacheJavaLangByteArray,
      kClassCacheJavaLangCharArray,
      kClassCacheJavaLangIntArray,
      kClassCacheJavaLangObject,
      kClassCacheJavaLangRefReference,
      kClassCacheJavaLangString,
      kClassCacheJavaLangStringBuffer,
      kClassCacheJavaLangStringBuilder,
      kClassCacheJavaLangStringFactory,
      kClassCacheJavaLangDouble,
      kClassCacheJavaLangFloat,
      kClassCacheJavaLangInteger,
      kClassCacheJavaLangLong,
      kClassCacheJavaLangShort,
      kClassCacheJavaLangMath,
      kClassCacheJavaLangStrictMath,
      kClassCacheJavaLangThread,
      kClassCacheJavaNioCharsetCharset,
      kClassCacheLibcoreIoMemory,
      kClassCacheSunMiscUnsafe,
      kClassCacheJavaLangSystem,
      kClassCacheLast
    };

    /**
     * To avoid multiple lookups of a method name string, we cache its string
     * index in the IndexCache. These are the indexes into the IndexCache
     * name_indexes array.
     */
    enum NameCacheIndex : uint8_t {  // unit8_t to save space, make larger if needed
      kNameCacheFirst = 0,
      kNameCacheReverse =  kNameCacheFirst,
      kNameCacheReverseBytes,
      kNameCacheDoubleToRawLongBits,
      kNameCacheLongBitsToDouble,
      kNameCacheFloatToRawIntBits,
      kNameCacheIntBitsToFloat,
      kNameCacheAbs,
      kNameCacheMax,
      kNameCacheMin,
      kNameCacheSqrt,
      kNameCacheCeil,
      kNameCacheFloor,
      kNameCacheRint,
      kNameCacheRound,
      kNameCacheReferenceGetReferent,
      kNameCacheCharAt,
      kNameCacheCompareTo,
      kNameCacheEquals,
      kNameCacheGetCharsNoCheck,
      kNameCacheIsEmpty,
      kNameCacheIndexOf,
      kNameCacheLength,
      kNameCacheInit,
      kNameCacheNewStringFromBytes,
      kNameCacheNewStringFromChars,
      kNameCacheNewStringFromString,
      kNameCacheCurrentThread,
      kNameCachePeekByte,
      kNameCachePeekIntNative,
      kNameCachePeekLongNative,
      kNameCachePeekShortNative,
      kNameCachePokeByte,
      kNameCachePokeIntNative,
      kNameCachePokeLongNative,
      kNameCachePokeShortNative,
      kNameCacheCompareAndSwapInt,
      kNameCacheCompareAndSwapLong,
      kNameCacheCompareAndSwapObject,
      kNameCacheGetInt,
      kNameCacheGetIntVolatile,
      kNameCachePutInt,
      kNameCachePutIntVolatile,
      kNameCachePutOrderedInt,
      kNameCacheGetLong,
      kNameCacheGetLongVolatile,
      kNameCachePutLong,
      kNameCachePutLongVolatile,
      kNameCachePutOrderedLong,
      kNameCacheGetObject,
      kNameCacheGetObjectVolatile,
      kNameCachePutObject,
      kNameCachePutObjectVolatile,
      kNameCachePutOrderedObject,
      kNameCacheArrayCopy,
      kNameCacheNumberOfLeadingZeros,
      kNameCacheNumberOfTrailingZeros,
      kNameCacheRotateRight,
      kNameCacheRotateLeft,
      kNameCacheLast
    };

    /**
     * To avoid multiple lookups of a method signature, we cache its proto
     * index in the IndexCache. These are the indexes into the IndexCache
     * proto_indexes array.
     */
    enum ProtoCacheIndex : uint8_t {  // unit8_t to save space, make larger if needed
      kProtoCacheFirst = 0,
      kProtoCacheI_I = kProtoCacheFirst,
      kProtoCacheJ_J,
      kProtoCacheS_S,
      kProtoCacheD_D,
      kProtoCacheDD_D,
      kProtoCacheF_F,
      kProtoCacheFF_F,
      kProtoCacheD_J,
      kProtoCacheJ_D,
      kProtoCacheF_I,
      kProtoCacheI_F,
      kProtoCacheII_I,
      kProtoCacheI_C,
      kProtoCacheString_I,
      kProtoCache_Z,
      kProtoCache_I,
      kProtoCache_Object,
      kProtoCache_Thread,
      kProtoCacheJ_B,
      kProtoCacheJ_I,
      kProtoCacheJ_S,
      kProtoCacheJB_V,
      kProtoCacheJI_V,
      kProtoCacheJJ_J,
      kProtoCacheJJ_V,
      kProtoCacheJS_V,
      kProtoCacheObject_Z,
      kProtoCacheJI_J,
      kProtoCacheObjectJII_Z,
      kProtoCacheObjectJJJ_Z,
      kProtoCacheObjectJObjectObject_Z,
      kProtoCacheObjectJ_I,
      kProtoCacheObjectJI_V,
      kProtoCacheObjectJ_J,
      kProtoCacheObjectJJ_V,
      kProtoCacheObjectJ_Object,
      kProtoCacheObjectJObject_V,
      kProtoCacheCharArrayICharArrayII_V,
      kProtoCacheObjectIObjectII_V,
      kProtoCacheIICharArrayI_V,
      kProtoCacheByteArrayIII_String,
      kProtoCacheIICharArray_String,
      kProtoCacheString_String,
      kProtoCache_V,
      kProtoCacheByteArray_V,
      kProtoCacheByteArrayI_V,
      kProtoCacheByteArrayII_V,
      kProtoCacheByteArrayIII_V,
      kProtoCacheByteArrayIIString_V,
      kProtoCacheByteArrayString_V,
      kProtoCacheByteArrayIICharset_V,
      kProtoCacheByteArrayCharset_V,
      kProtoCacheCharArray_V,
      kProtoCacheCharArrayII_V,
      kProtoCacheIICharArray_V,
      kProtoCacheIntArrayII_V,
      kProtoCacheString_V,
      kProtoCacheStringBuffer_V,
      kProtoCacheStringBuilder_V,
      kProtoCacheLast
    };

  private:
    /**
     * The maximum number of method parameters we support in the ProtoDef.
     */
    static constexpr uint32_t kProtoMaxParams = 6;

    /**
     * The method signature (proto) definition using cached class indexes.
     * The return_type and params are used with the IndexCache to look up
     * appropriate class indexes to be passed to DexFile::FindProtoId().
     */
    struct ProtoDef {
      ClassCacheIndex return_type;
      uint8_t param_count;
      ClassCacheIndex params[kProtoMaxParams];
    };

    /**
     * The method definition using cached class, name and proto indexes.
     * The class index, method name index and proto index are used with
     * IndexCache to look up appropriate parameters for DexFile::FindMethodId().
     */
    struct MethodDef {
      ClassCacheIndex declaring_class;
      NameCacheIndex name;
      ProtoCacheIndex proto;
    };

    /**
     * The definition of an intrinsic function binds the method definition
     * to an Intrinsic.
     */
    struct IntrinsicDef {
      MethodDef method_def;
      InlineMethod intrinsic;
    };

    /**
     * Cache for class, method name and method signature indexes used during
     * intrinsic function lookup to avoid multiple lookups of the same items.
     *
     * Many classes have multiple intrinsics and/or they are used in multiple
     * method signatures and we want to avoid repeated lookups since they are
     * not exactly cheap. The method names and method signatures are sometimes
     * reused and therefore cached as well.
     */
    struct IndexCache {
      IndexCache();

      uint32_t class_indexes[kClassCacheLast - kClassCacheFirst];
      uint32_t name_indexes[kNameCacheLast - kNameCacheFirst];
      uint32_t proto_indexes[kProtoCacheLast - kProtoCacheFirst];
    };

    static const char* const kClassCacheNames[];
    static const char* const kNameCacheNames[];
    static const ProtoDef kProtoCacheDefs[];
    static const IntrinsicDef kIntrinsicMethods[];

    static const uint32_t kIndexNotFound = static_cast<uint32_t>(-1);
    static const uint32_t kIndexUnresolved = static_cast<uint32_t>(-2);

    ReaderWriterMutex lock_;
    /*
     * Maps method indexes (for the particular DexFile) to Intrinsic defintions.
     */
    SafeMap<uint32_t, InlineMethod> inline_methods_ GUARDED_BY(lock_);
    const DexFile* dex_file_;
};
---------------- InlineMethod ---------------------------------------------------
<src art/runtime/quick/inline_method_analyser.h>
struce InlineMethod {
  InlineMethodOpcode opcode;
  InlineMethodFlags flag;
  union {
    uint64_t data;
    InlineIGetIPutData ifield_data;
    InlineReturnArgData return_data;
  } d;
}
-------
Desc:
* InlineMethodOpcode contains intrinsics (like kIntrinsicIndexOf) and InlineOp (kInlineOpNop, ReturnArg, NonWideConst,IGet/IPut and StringInit)
* InlineMethodFlags : NoInlineMethodFlags, kInlineIntrinsic ,  kInlineSpecial 
* InlineIGetIPutData: 
    struct InlineIGetIPutData {
      // The op_variant below is DexMemAccessType but the runtime doesn't know that enumeration.
      uint16_t op_variant : 3;
      uint16_t method_is_static : 1;
      uint16_t object_arg : 4;
      uint16_t src_arg : 4;  // iput only
      uint16_t return_arg_plus1 : 4;  // iput only, method argument to return + 1, 0 = return void.
      uint16_t field_idx;
      uint32_t is_volatile : 1;
      uint32_t field_offset : 31;
    };
* InlineReturuArgData: 
    struct InlineReturnArgData {
      uint16_t arg;
      uint16_t is_wide : 1;
      uint16_t uint16_t is_object : 1;
      uint16_t reserved : 14;
      uint32_t reserved2;
    };
------------------------------------------------------------------------------------------
******************************************************************************************
******************************************************************************************
QuickCompilerCallbacks() Desc:
* it contains two components:
  ** verification_results_ contains:
    *** compiler_options_,
    *** VerifiedMethodMap verified_methods_; contains MethodReference(dexfile+index) and VerifiedMethods(meta info like gc map.) 
    *** rejected classes set.
  ** method_inliner_map, contains:
    *** inliners_ (map with dexfile and DexFileMethodInliner(contains dexfile and map<m_index, InlineMethod>))
    InlineMethod describes the method need to be inlined (opcode, flag, data).
    
===========================================================================================
===========================================================================================


===========================================================================================
=================== PrepareRuntimeOptions() ===============================================
<src dex2oat/dex2oat.cc>
* Runtime-option  --- value --- (dex2oat options)

* "-Xbootclasspath:" --- dex_filenames_ (--dex-file=)
* "-Xbootclasspath-locations:" --- dex_locations_ ("--dex-location=")
* "-Ximage:" --- boot_image_fileiname_ (--boot-image= or getenv(ANDROID_ROOT) + "/framework/boot.art")
* "compilercallbacks" --- callback
* "imageinstructionset" --- GetInstructionSetString(instruction_set)
* "-Xno-dex-file-fallback" --- nullptr (only if !BootImage())
* "-Xno-sig-chain" --- nullptr

==========================================================================================
=================== CreateRuntime(std::move(runtime_options)) ============================
<src dex2oat/dex2oat.cc>





